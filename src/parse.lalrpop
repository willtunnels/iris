use crate::ast::{self, raw_ast as raw};

grammar;

match {
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { },
    _
}

CommaSep<T>: Vec<T> = {
  <mut items: (<T> ",")*> <last: T?> => match last {
    None => items,
    Some(item) => {
      items.push(item);
      items
    }
  },
};

Spanned<T>: syntax::Expr = {
  <lo: @L> <expr:T> <hi: @R> => {
    if let ast::Span(_, _) = &expr {
      expr
    } else {
      ast::Expr(ast::Span(lo, hi), Box::new(expr))
    }
  },
};

#[inline]
Ident: ast::Ident = {
    r"[a-zA-z][a-zA-Z0-9]*" => ast::Ident(<>.into()),
};

IdentPath: ast::IdentPath = {
    <mut items: (<Ident> "::")*> <last: Ident> => {
        items.push(last);
        ast::IdentPath(items)
    },
};

Generics: raw::Generics = {
    <lo: @L> <params: ("<" <CommaSep<Ident>> ">")?> <hi: @R> =>
        raw::Generics { params: params.unwrap_or_default(), span: ast::Span(lo, hi) },
};

FuncRet: raw::Type = {
    ("->" <Type>)? => <>.unwrap_or_else(|| raw::Type {
        kind: raw::TypeKind::Tuple(Vec::new()),
        // TODO: is there a better span to use here?
        span: ast::Span(0, 0),
    }),
};

Type_: raw::TypeKind = {
    <name: Ident> <params: ("<" <CommaSep<Type>> ">")?> => raw::TypeKind::Named(name, params.unwrap_or_default()),
    "fn" "(" <args: CommaSep<Type>> ")" <ret: FuncRet> => raw::TypeKind::Func(args, Box::new(ret)),
    "(" <CommaSep<Type>> ")" => raw::TypeKind::Tuple(<>),
};

Type: raw::Type = {
    <lo: @L> <kind: Type_> <hi: @R> =>
        raw::Type { kind, span: ast::Span(lo, hi) },
};

Lit: raw::Lit = {
    r"'.'" => raw::Lit::Char(<>.chars().next().unwrap()),
    r"[0-9]+i8" => raw::Lit::I8(<>[..<>.len() - 2].parse().unwrap()),
    r"[0-9]+i16" => raw::Lit::I16(<>[..<>.len() - 3].parse().unwrap()),
    r"[0-9]+i32" => raw::Lit::I32(<>[..<>.len() - 3].parse().unwrap()),
    r"[0-9]+i64" => raw::Lit::I64(<>[..<>.len() - 3].parse(). unwrap()),
    r"[0-9]+isize" => raw::Lit::ISize(<>[..<>.len() - 5].parse().unwrap()),
    r"[0-9]+u8" => raw::Lit::U8(<>[..<>.len() - 2].parse().unwrap()),
    r"[0-9]+u16" => raw::Lit::U16(<>[..<>.len() - 3].parse().unwrap()),
    r"[0-9]+u32" => raw::Lit::U32(<>[..<>.len() - 3].parse().unwrap()),
    r"[0-9]+u64" => raw::Lit::U64(<>[..<>.len() - 3].parse().unwrap()),
    r"[0-9]+usize" => raw::Lit::USize(<>[..<>.len() - 5].parse().unwrap()),
    r"[0-9]+\.[0-9]+f32" => raw::Lit::F32(<>[..<>.len() - 3].parse().unwrap()),
    r"[0-9]+\.[0-9]+f64" => raw::Lit::F64(<>[..<>.len() - 3].parse().unwrap()),
    r#"".*""# => raw::Lit::Str(<>.to_owned()),
};

Expr: raw::Expr = {
    <Ident> => raw::Expr::Var(<>),
    <Lit> => raw::Expr::Lit(<>),
};

Block: raw::Block = {
    "{" <stmts: (<Stmt> ";")*> <ret: Expr> "}" =>
        raw::Block { stmts, ret: Box::new(ret) },
};

Stmt: raw::Stmt = {
    "let" <Ident> <(":" <Type>)?> "=" <Expr> =>
        raw::Stmt::Assign(<>),
}

TypeDef: raw::TypeDef = {
    "extern" "type" <name: Ident> <generics: Generics> "=" <path: IdentPath> ";" =>
        raw::TypeDef { name, generics, path },
};

FuncSig: (ast::Ident, raw::Generics, Vec<(ast::Ident, raw::Type)>, raw::Type) = {
    "fn" <name: Ident> <generics: Generics> "(" <args: CommaSep<(<Ident> ":" <Type>)>> ")" <ret: FuncRet> =>
        (name, generics, args, ret),
};

FuncDef: raw::FuncDef = {
    "extern" <sig: FuncSig> "=" <path: IdentPath> ";" => raw::FuncDef {
        name: sig.0,
        generics: sig.1,
        args: sig.2,
        ret: sig.3,
        body: raw::FuncBody::External(path),
    },
    <sig: FuncSig> <block: Block> => raw::FuncDef {
        name: sig.0,
        generics: sig.1,
        args: sig.2,
        ret: sig.3,
        body: raw::FuncBody::Internal(block),
    }
};

Item_: raw::ItemKind = {
    TypeDef => raw::ItemKind::TypeDef(<>),
    FuncDef => raw::ItemKind::FuncDef(<>),
};

Item: raw::Item = {
    <lo: @L> <kind: Item_> <hi: @R> =>
        raw::Item { kind, span: ast::Span(lo, hi) },
};

pub Program: raw::Program = {
    Item* => raw::Program { items: <> },
};
