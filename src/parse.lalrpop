use crate::ast::{self, raw_ast as raw};

grammar;
 
match {
    r"//[^\n\r]*[\n\r]*" => { }, // Skip single line comments
} else {
    _
}

CommaSep<T>: Vec<T> = {
  <mut items: (<T> ",")*> <last: T?> => match last {
    None => items,
    Some(item) => {
      items.push(item);
      items
    }
  },
};

Spanned<T>: raw::Expr = {
  <lo: @L> <expr: T> <hi: @R> => {
    if let raw::Expr::Span(_, _) = &expr {
      expr
    } else {
      raw::Expr::Span(ast::Span(lo, hi), Box::new(expr))
    }
  },
};

#[inline]
Ident: ast::Ident = {
    r"[A-Za-z][A-Za-z0-9]*" => ast::Ident(<>.to_owned()),
};

IdentPath : ast::IdentPath = {
    <mut items: (<Ident> "::")*> <last: Ident> => {
        items.push(last);
        ast::IdentPath(items)
    },
};

TypeKind: raw::TypeKind = {
    <Ident> =>
        raw::TypeKind::Named(<>, Vec::new()),
    "(" <CommaSep<Type>> ")" =>
        raw::TypeKind::Tuple(<>),
    "fn" "(" <args: CommaSep<Type>> ")" "->" <ret: Type> =>
        raw::TypeKind::Func(args, Box::new(ret)),
};

Type: raw::Type = {
    <lo: @L> <kind: TypeKind> <hi: @R> => raw::Type {
        kind,
        span: ast::Span(lo, hi)
    },
};

Generics: raw::Generics = {
    <lo: @L> "<" <params: CommaSep<Ident>> ">" <hi: @R> => raw::Generics {
        params,
        span: ast::Span(lo, hi),
    },
};

FuncSig: (ast::Ident, raw::Generics, Vec<(ast::Ident, raw::Type)>, raw::Type) = {
    "fn" <name: Ident>
    <generics: Generics> "(" <args: CommaSep<(<Ident> ":" <Type>)>> ")"
    "->" <ret: Type> =>
        (name, generics, args, ret),
};

FuncDef: raw::FuncDef = {
    "extern" <sig: FuncSig> "=" <path: IdentPath> ";" => raw::FuncDef {
        name: sig.0,
        generics: sig.1,
        args: sig.2,
        ret: sig.3,
        body: raw::FuncBody::External(path),
    },
    <sig: FuncSig> <body: BlockExpr> => raw::FuncDef {
        name: sig.0,
        generics: sig.1,
        args: sig.2,
        ret: sig.3,
        body: raw::FuncBody::Internal(body),
    },
};

TypeDef: raw::TypeDef = {
    "extern" "type" <name: Ident> <generics: Generics> "=" <path: IdentPath> ";" =>
        raw::TypeDef { name, generics, path },
};

ItemKind: raw::ItemKind = {
    <FuncDef> => raw::ItemKind::FuncDef(<>),
    <TypeDef> => raw::ItemKind::TypeDef(<>),
};

Item: raw::Item = {
    <lo: @L> <kind: ItemKind> <hi: @R> => raw::Item {
        kind,
        span: ast::Span(lo, hi)
    },
};

// TODO: maybe we should have a unary negation instead of parsing a "-" here
Lit: raw::Lit = {
    r"'.'" => raw::Lit::Char(<>.chars().next().unwrap()),
    r"-?[0-9]+i8" => raw::Lit::I8(<>.parse().unwrap()),
    r"-?[0-9]+i16" => raw::Lit::I16(<>.parse().unwrap()),
    r"-?[0-9]+i32" => raw::Lit::I32(<>.parse().unwrap()),
    r"-?[0-9]+i64" => raw::Lit::I64(<>.parse(). unwrap()),
    r"-?[0-9]+isize" => raw::Lit::ISize(<>.parse().unwrap()),
    r"[0-9]+u8" => raw::Lit::U8(<>.parse().unwrap()),
    r"[0-9]+u16" => raw::Lit::U16(<>.parse().unwrap()),
    r"[0-9]+u32" => raw::Lit::U32(<>.parse().unwrap()),
    r"[0-9]+u64" => raw::Lit::U64(<>.parse().unwrap()),
    r"[0-9]+usize" => raw::Lit::USize(<>.parse().unwrap()),
    r"-?[0-9]+\.[0-9]+f32" => raw::Lit::F32(<>.parse().unwrap()),
    r"-?[0-9]+\.[0-9]+f64" => raw::Lit::F64(<>.parse().unwrap()),
    r#"".*""# => raw::Lit::Str(<>.to_owned()),
};

AtomicExpr_: raw::Expr = {
    <Ident> => raw::Expr::Var(<>),
    <Lit> => raw::Expr::Lit(<>),
};

AtomicExpr: raw::Expr = {
    <Spanned<AtomicExpr_>>,
};

AppExpr_: raw::Expr = {
    <AtomicExpr>,

    <func: Expr> "(" <args: CommaSep<Expr>> ")" => raw::Expr::App(Box::new(func), args),
};

AppExpr: raw::Expr = {
    <Spanned<AppExpr_>>,
}

ArithExpr1_: raw::Expr = {
    <AppExpr>,

    <l: ArithExpr1> "*" <r: AppExpr> => raw::binop(raw::BinOpKind::Mul, l, r),
    <l: ArithExpr1> "/" <r: AppExpr> => raw::binop(raw::BinOpKind::Div, l, r),
    <l: ArithExpr1> "%" <r: AppExpr> => raw::binop(raw::BinOpKind::Mod, l, r),
};

ArithExpr1: raw::Expr = {
    <Spanned<ArithExpr1_>>,
}

ArithExpr2_: raw::Expr = {
    <ArithExpr1>,

    <l: ArithExpr2> "+" <r: ArithExpr1> => raw::binop(raw::BinOpKind::Add, l, r),
    <l: ArithExpr2> "-" <r: ArithExpr1> => raw::binop(raw::BinOpKind::Sub, l, r),
};

ArithExpr2: raw::Expr = {
    <Spanned<ArithExpr2_>>,
}

// TODO: should we require parentheses, like Rust, instead of going left to right?
CompExpr_: raw::Expr = {
    <ArithExpr2>,

    <l: CompExpr> "==" <r: ArithExpr2> => raw::binop(raw::BinOpKind::Eq, l, r),
    <l: CompExpr> "!=" <r: ArithExpr2> => raw::binop(raw::BinOpKind::NotEq, l, r),
    <l: CompExpr> ">" <r: ArithExpr2> => raw::binop(raw::BinOpKind::Gt, l, r),
    <l: CompExpr> ">=" <r: ArithExpr2> => raw::binop(raw::BinOpKind::Gte, l, r),
    <l: CompExpr> "<" <r: ArithExpr2> => raw::binop(raw::BinOpKind::Lt, l, r),
    <l: CompExpr> "<=" <r: ArithExpr2> => raw::binop(raw::BinOpKind::Lte, l, r),
};

CompExpr: raw::Expr = {
    <Spanned<CompExpr_>>,
}

AndExpr_: raw::Expr = {
    <CompExpr>,

    <l: AndExpr> "&&" <r: CompExpr> => raw::binop(raw::BinOpKind::And, l, r),
};

AndExpr: raw::Expr = {
    <Spanned<AndExpr_>>,
}

OrExpr_: raw::Expr = {
    <AndExpr>,

    <l: OrExpr> "||" <r: AndExpr> => raw::binop(raw::BinOpKind::Or, l, r),
};

OrExpr: raw::Expr = {
    <Spanned<OrExpr_>>,
}

BlockExpr: raw::Expr = {
    "{" <stmts: Stmt*> <ret: Expr> "}" =>
        raw::Expr::Block(raw::Block { stmts, ret: Box::new(ret) }),
};

Expr: raw::Expr = {
    <BlockExpr>,
}

Stmt: raw::Stmt = {
    <lo: @L> "let" <var: Ident> <type_: (":" Type)?> "=" <expr: Expr> <hi: @R> =>
        raw::Stmt::Span(
            ast::Span(lo, hi),
            Box::new(raw::Stmt::Assign(
                var,
                type_.map(|(_, type_)| type_),
                expr
            )),
        )
};

pub Program: raw::Program = {
    <items: Item*> => raw::Program { items },
};
