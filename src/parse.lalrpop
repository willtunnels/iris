use crate::ast::{self, raw_ast as raw};

grammar;
 
match {
    r"//[^\n\r]*[\n\r]*" => { }, // Skip single line comments
} else {
    _
}

CommaSep<T>: Vec<T> = {
  <mut items: (<T> ",")*> <last: T?> => match last {
    None => items,
    Some(item) => {
      items.push(item);
      items
    }
  }
};

#[inline]
Ident: ast::Ident = {
    r"[A-Za-z][A-Za-z0-9]*" => ast::Ident(<>.to_owned())
}

IdentPath : ast::IdentPath = {
    <mut items: (<Ident> "::")*> <last: Ident> => {
        items.push(last);
        ast::IdentPath(items)
    }
}

TypeKind: raw::TypeKind = {
    <Ident> =>
        raw::TypeKind::Named(<>, Vec::new()),
    "(" <CommaSep<Type>> ")" =>
        raw::TypeKind::Tuple(<>),
    "fn" "(" <args: CommaSep<Type>> ")" "->" <ret: Type> =>
        raw::TypeKind::Func(args, Box::new(ret)),
}

Type: raw::Type = {
    <lo: @L> <kind: TypeKind> <hi: @R> => raw::Type {
        kind,
        span: ast::Span(lo, hi)
    }
}

Generics: raw::Generics = {
    <lo: @L> "<" <params: CommaSep<Ident>> ">" <hi: @R> => raw::Generics {
        params,
        span: ast::Span(lo, hi),
    }
}

FuncSig: (ast::Ident, raw::Generics, Vec<(ast::Ident, raw::Type)>, raw::Type) = {
    "fn" <name: Ident>
    <generics: Generics> "(" <args: CommaSep<(<Ident> ":" <Type>)>> ")"
    "->" <ret: Type> =>
        (name, generics, args, ret),
}

FuncBody: raw::Expr = {
    <lo: @L> <block: Block> <hi: @R> => raw::Expr {
        kind: raw::ExprKind::Block(block),
        span: ast::Span(lo, hi),
    }
}

FuncDef: raw::FuncDef = {
    "extern" <sig: FuncSig> "=" <path: IdentPath> ";" => raw::FuncDef {
        name: sig.0,
        generics: sig.1,
        args: sig.2,
        ret: sig.3,
        body: raw::FuncBody::External(path),
    },
    <sig: FuncSig> <body: FuncBody> => raw::FuncDef {
        name: sig.0,
        generics: sig.1,
        args: sig.2,
        ret: sig.3,
        body: raw::FuncBody::Internal(body),
    }
}

TypeDef: raw::TypeDef = {
    "extern" "type" <name: Ident> <generics: Generics> "=" <path: IdentPath> ";" =>
        raw::TypeDef { name, generics, path }
}

ItemKind: raw::ItemKind = {
    <FuncDef> => raw::ItemKind::FuncDef(<>),
    <TypeDef> => raw::ItemKind::TypeDef(<>),
}

Item: raw::Item = {
    <lo: @L> <kind: ItemKind> <hi: @R> => raw::Item {
        kind,
        span: ast::Span(lo, hi)
    }
}

Lit: raw::Lit = {
    r"'.'" => raw::Lit::Char(<>.chars().next().unwrap()),
    r"-?[0-9]+i8" => raw::Lit::I8(<>.parse().unwrap()),
    r"-?[0-9]+i16" => raw::Lit::I16(<>.parse().unwrap()),
    r"-?[0-9]+i32" => raw::Lit::I32(<>.parse().unwrap()),
    r"-?[0-9]+i64" => raw::Lit::I64(<>.parse(). unwrap()),
    r"-?[0-9]+isize" => raw::Lit::ISize(<>.parse().unwrap()),
    r"[0-9]+u8" => raw::Lit::U8(<>.parse().unwrap()),
    r"[0-9]+u16" => raw::Lit::U16(<>.parse().unwrap()),
    r"[0-9]+u32" => raw::Lit::U32(<>.parse().unwrap()),
    r"[0-9]+u64" => raw::Lit::U64(<>.parse().unwrap()),
    r"[0-9]+usize" => raw::Lit::USize(<>.parse().unwrap()),
    r"-?[0-9]+\.[0-9]+f32" => raw::Lit::F32(<>.parse().unwrap()),
    r"-?[0-9]+\.[0-9]+f64" => raw::Lit::F64(<>.parse().unwrap()),
    r#"".*""# => raw::Lit::Str(<>.to_owned()),

}

Block: raw::Block = {
    "{" <stmts: Stmt*> <ret: Expr> "}" =>
        raw::Block { stmts, ret: Box::new(ret) },
}

ExprKind: raw::ExprKind = {
    <Lit> =>
        raw::ExprKind::Lit(<>),
    <Ident> =>
        raw::ExprKind::Var(<>),
    //"|" <args: CommaSep<Ident>> "|" <expr: Expr> =>
    //    raw::ExprKind::Lam(args, Box::new(expr)),
    //"(" <CommaSep<Expr>> ")" =>
    //    raw::ExprKind::Tuple(<>),
    //<expr1: Expr> "(" <expr2: Expr> ")" =>
    //    raw::ExprKind::App(Box::new(expr1), Box::new(expr2)),
}

Expr: raw::Expr = {
    <lo: @L> <kind: ExprKind> <hi: @R> =>
        raw::Expr { kind, span: ast::Span(lo, hi) }
}

StmtKind: raw::StmtKind = {
    "let" <var: Ident> <type_: (":" Type)?> "=" <expr: Expr> =>
        raw::StmtKind::Assign(var, type_.map(|(_, type_)| type_), expr),
}

Stmt: raw::Stmt = {
    <lo: @L> <kind: StmtKind> <hi: @R> =>
        raw::Stmt { kind, span: ast::Span(lo, hi) }
}

pub Program: raw::Program = {
    <items: Item*> => raw::Program { items },
}
