use crate::{ast, ast::raw_ast as raw};
use lalrpop_util::ParseError;

grammar;
 
match {
    r"//[^\n\r]*[\n\r]*" => { }, // Skip single line comments
    r"True|False"
} else {
    _
}

// For making a vector out of a list separated by S, a string
#[inline]
Sep<T, S>: Vec<T> = {
    <items: (<T> S)*> <last: T?> => match last {
        None => items,
        Some(item) => {
            items.push(item);
            items
        }
    }
}

// For making a vector of size at least 1
#[inline]
SepPlus<T, S>: Vec<T> = {
    <first: T> <rest: (S <T>)*> <last: S?> => {
        rest.insert(0, first);
        rest
    }
}

// Identifier: name of variable, type, function, or module. Must start with capital.
#[inline]
Ident: ast::Ident = {
    r"[A-Z][A-Za-z0-9_]*" => ast::Ident(<>)
}

#[inline]
IdentPath : ast::IdentPath = {
    <p: Sep<Ident, "::">> => ast::IdentPath(p)
}

Lit : raw::Lit = {
    r"'[0-9A-Za-z]'|'\\n'|'\\0'" => raw::Lit::Char(<>),
    r"True|False" => raw::Lit::Bool(<>),
    <(<r"-?[0-9]+"> "I8")> => raw::Lit::I8(<>),
    <(<r"-?[0-9]+"> "I16")> => raw::Lit::I16(<>),
    <(<r"-?[0-9]+"> "I32")> => raw::Lit::I32(<>),
    <(<r"-?[0-9]+"> "I64")> => raw::Lit::I64(<>),
    <(<r"-?[0-9]+"> "ISize")> => raw::Lit::ISize(<>)
    <(<r"[0-9]+"> "U8")> => raw::Lit::U8(<>),
    <(<r"[0-9]+"> "U16")> => raw::Lit::U16(<>),
    <(<r"[0-9]+"> "U32")> => raw::Lit::U32(<>),
    <(<r"[0-9]+"> "U64")> => raw::Lit::U64(<>),
    <(<r"[0-9]+"> "USize")> => raw::Lit::USize(<>),
    <(<r"-?[0-9]+\.[0-9]+"> "F32")> => raw:Lit::F32(<>),
    <(<r"-?[0-9]+\.[0-9]+"> "F64")> => raw:Lit::F64(<>),
    r#"".*""# => raw::Lit::Str(<>)
}

// let x : I32 = 2 + 3;
StmtKind : raw::StmtKind = {
    "let" <v: Ident> <t: (":" <Type>)?> "=" <e: Expr> ";" => raw::StmtKind::Assign(v, t, e)
}


Stmt : raw::Stmt = {
    <lo:@L> <k:StmtKind> <hi:@R> => raw::Stmt {
        kind: k,
        span(lo, hi),
    }
}

Block : raw::Block = {
    "{" <s: Sep<Stmt, ";">> <r: Expr> "}" => raw::Block {
        stmts: s,
        ret: Box::new(r),
    }
}

UOpKind : raw::UopKind = {
    "!" => raw::UopKind::Not,
}

UTerm : raw::UTerm = {
    <l: Lit> => raw::UTerm::Lit(l),
    "(" <e: Expr> ")" => raw::UTerm::Quantity(Box::new(e)),
    <v: Ident> => raw::UTerm::Var(v),
}

BinOp6Kind: raw::BinOp6Kind = {
    "." => raw::BinOp6Kind::Dot,
}

BinTerm6 : raw::BinTerm6 = {
    <op: UOpKind> <u: UTerm> => raw::BinTerm6::UOp(op, u),
    <u: UTerm> => raw::BinTerm6::UTerm(u),
}

BinOp5Kind : raw::BinOp5Kind = {
    "*" => raw::BinOp5Kind::Times,
    "/" => raw::BinOp5Kind::Divide,
    "%" => raw::BinOp5Kind::Mod,
}

BinTerm5 : raw::BinTerm5 = {
    <t1: BinTerm5> <op: BinOp6Kind> <t2: BinTerm6> => raw::BinTerm5::BinOp6(op, Box::new(t1), t2),
    <t: BinTerm6> => raw::BinTerm5::BinTerm6(t),
}

BinOp4Kind : raw::BinOp4Kind = {
    "+" => raw::BinOp4Kind::Plus,
    "-" => raw::BinOp4Kind::Minus,
}

BinTerm4 : raw::BinTerm4 = {
    <t1: BinTerm4> <op: BinOp5Kind> <t2: BinTerm5> => raw::BinTerm4::BinOp5(op, Box::new(t1), t2),
    <t: BinTerm5> => raw::BinTerm4::BinTerm5(t),
}

BinOp3Kind : raw::BinOp3Kind = {
    "==" => raw::BinOp3Kind::Equality,
    "!=" => raw::BinOp3Kind::Inequality,
    "<" => raw::BinOp3Kind::LessThan,
    ">" => raw::BinOp3Kind::GreaterThan,
    "<=" => raw::BinOp3Kind::Leq,
    ">=" => raw::BinOp3Kind::Geq,
}

BinTerm3 : raw::BinTerm3 = {
    <t1: BinTerm3> <op: BinOp4Kind> <t2: BinTerm4> => raw::BinTerm3::BinOp4(op, Box::new(t1), t2),
    <t: BinTerm4> => raw::BinTerm3::BinTerm4(t),
}

BinOp2Kind : raw::BinOp2Kind = {
    "&&" => raw::BinOp2Kind::And,
}

BinTerm2 : raw::BinTerm2 = {
    <t1: BinTerm2> <op: BinOp3Kind> <t2: BinTerm3> => raw::BinTerm2::BinOp3(op, Box::new(t1), t2),
    <t: BinTerm3> => raw::BinTerm2::BinTerm3(t),
}

BinOp1Kind : raw::BinOp1Kind = {
    "||" => raw::BinOp1Kind::Or,
}

BinTerm1 : raw::BinTerm1 = {
    <t1: BinTerm1> <op: BinOp2Kind> <t2: BinTerm2> => raw::BinTerm1::BinOp2(op, Box::new(t1), t2),
    <t: BinTerm2> => raw::BinTerm1::BinTerm2(t)
}

ExprKind : raw::ExprKind = {
    // lambda
    "|" <p: SepPlus<Ident, ",">> "|" <e: Expr> => raw::ExprKind::Lam(p, Box::new(e)),
    // tuple
    "(" <t: Sep<Expr, ",">> ")" => raw::ExprKind::Tuple(t),
    // function application
    <f: Expr> "(" <args: Sep<Expr, ",">> ")" => raw::ExprKind::App(Box::new(f), args),
    // if statement
    "if" <bexp: Expr> <c1: Block> "else" <c2: Block> => raw::ExprKind::If(Box::new(bexp), c1, c2),
    // Block
    <b: Block> => raw::ExprKind::Block(b),
    
    // Unary and Binary Operations
    <op: UOpKind> <u: UTerm> => raw::ExprKind::UnaryOp(op, u),
    <u: UTerm> => raw::ExprKind::UTerm(u),
    <e: Expr> <op: BinOp1Kind> <t: BinTerm1> => raw::ExprKind::BinOp1(op, Box::new(e1), t),
    <t: BinTerm1> => raw::ExprKind::BinTerm1(t),
}

Expr : raw::Expr = {
    <lo:@L> <k:ExprKind> <hi:@R> => raw::Expr {
        kind: k,
        span: Span(lo, hi),
    }
}

// Handles internal only. External has already been taken care of.
FuncBody : raw::FuncBody = {
    "{" <e: Expr> "}" => raw::FuncBody::Internal(e)
}

// <T, V>
Generics : raw::Generics = {
    <lo:@L> "<" <p: Sep<Ident, ",">> ">" <hi:@R> => raw::Generics {
        params: p,
        span: Span(lo, hi),
    }
}

// extern type Foo = crate::fo::Foo;
TypeDef : raw::TypeDef = {
    "extern" "type" <n: Ident> <g: Generics?> "=" <p: IdentPath> ";" => raw::TypeDef {
        name: n,
        generics: g,
        path: p,
    }
}

// Foo<A, B> => named
// fn(A, B) -> C => Func
// (Foo, Bar) => Tuple
TypeKind : raw::TypeKind = {
    <n: Ident> <p: Sep<Type, ",">?> => raw::TypeKind::Named(n, p),
    "fn" "(" <p: Sep<Type, ",">> ")" "->" <ret: Type> => raw::TypeKind::Func(p, Box::new(ret)),
    "(" <types: Sep<Type, ",">> ")" => raw::TypeKind::Tuple(types),
}


Type : raw::Type = {
    <lo:@L> <i:Ident> <hi:@R> => raw::Type {
        kind: k,
        span(lo, hi),
    }
}

// parses foo<T>(arg1: Type1, arg2: Type2) -> Type3
//Question: How to create a vector of tuples with regex syntax??
FuncSig : raw::FuncSig = {
    <n:Ident> <g:Generics?> "(" <a:Sep<(<Ident> ":" <Type>), ",">?> ")" "->" <r:Type> => 
    raw::FuncSig {
        name: n,
        generics: g,
        args: a,
        ret: r,
    }
}

// extern fn foo<T>(x: EqGuard<T>, y: EqGuard<T>) -> EqGuard<T> {body}
FuncDef : raw::FuncDef = {
    "extern" "fn" <s: FuncSig> ";" => raw::FuncDef {
            sig: s,
            body: raw::FuncBody::External,
        },

    "fn" <s: FuncSig> <b:FuncBody> => raw::FuncDef {
            sig: s,
            body: b,
        }
}

ItemKind : raw::ItemKind = {
    <f:FuncDef> => raw::ItemKind::FuncDef(f),
    <t:TypeDef> => raw::ItemKind::Typedef(t)
}


Item : raw::Item = {
    <lo:@L> <k:ItemKind> <hi:@R> => raw::Item {
        kind: k,
        span: ast::Span(lo, hi),
    }
}

pub Program : raw::Program = {
    <i:Item*> => raw::Program {items: i}
}
