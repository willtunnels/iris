use crate::{ast, ast::raw_ast as raw};
use lalrpop_util::ParseError;

grammar;
 
match {
    r"//[^\n\r]*[\n\r]*" => { }, // Skip single line comments
    r"True|False"
} else {
    _
}

// For making a vector out of a list separated by S, a string
#[inline]
Sep<T, S>: Vec<T> = {
    <items: (<T> S)*> <last: T?> => match last {
        None => items,
        Some(item) => {
            items.push(item);
            items
        }
    }
}

// Identifier: name of variable, type, function, or module. Must start with capital.
#[inline]
Ident: ast::Ident = {
    r"[A-Z][A-Za-z0-9_]*" => ast::Ident(<>)
}

#[inline]
IdentPath : ast::IdentPath = {
    <p: Sep<Ident, "::">> => ast::IdentPath(p)
}

Lit : raw::Lit = {
    r"'[0-9A-Za-z]'|'\\n'|'\\0'" => raw::Lit::Char(<>),
    r"True|False" => raw::Lit::Bool(<>),
    <r"[0-9]+"> "I8" => raw::Lit::I8(<>),
    <r"[0-9]+"> "I16" => raw::Lit::I16(<>),
    <r"[0-9]+"> "I32" => raw::Lit::I32(<>),
    <r"[0-9]+"> "I64" => raw::Lit::I64(<>),
    <r"[0-9]+"> "ISize" => raw::Lit::ISize(<>)
    <r"[0-9]+"> "U8" => raw::Lit::U8(<>),
    <r"[0-9]+"> "U16" => raw::Lit::U16(<>),
    <r"[0-9]+"> "U32" => raw::Lit::U32(<>),
    <r"[0-9]+"> "U64" => raw::Lit::U64(<>),
    <r"[0-9]+"> "USize" => raw::Lit::USize(<>),
    <r"[0-9]+\.[0-9]+"> "F32" => raw:Lit::F32(<>),
    <r"[0-9]+\.[0-9]+"> "F64" => raw:Lit::F64(<>),
    r#"".*""# => raw::Lit::Str(<>)
}

// let x : I32 = 2 + 3;
StmtKind : raw::StmtKind = {
    "let" <v: Ident> <t: (":" <Type>)?> "=" <e: Expr> ";" => raw::StmtKind::Assign(v, t, e)
}


Stmt : raw::Stmt = {
    <lo:@L> <k:StmtKind> <hi:@R> => raw::Stmt {
        kind: k,
        span(lo, hi)
    }
}

Block : raw::Block = {
    "{" <s: Sep<Stmt, ";">> <r: Expr> "}" => raw::Block {
        stmts: s,
        ret: Box::new(r)
    }
}

BinOpKind : raw::BinOpKind = {
    "&&" => raw::BinOpKind::And,
    "||" => raw::BinOpKind::Or,
    "!" => raw::BinOpKind::Not,
    "+" => raw::BinOpKind::Plus,
    "-" => raw::BinOpKind::Minus,
    "*" => raw::BinOpKind::Times,
    "/" => raw::BinOpKind::Divide,
    "%" => raw::BinOpKind::Mod
}

// 2.0
// myvar
// |x, y| x + y
// (x+y, x+z)
// x + 2 + 3
// f(x+2, y+1)
// (1, 2).0
// if x > 0 {x = x + 1;} else {x}
// {x=x+1; x}
ExprKind : raw::ExprKind = {
    "(" <e: Expr> ")" => e,
    <l: Lit> => raw::ExprKind::Lit(l),
    <v: Ident> => raw::ExprKind::Var(v),
    "|" <p: Sep<Ident, ",">> "|" <e: Expr> => raw::ExprKind::Lam(p, Box::new(e)),
    "(" <t: Sep<Expr, ",">> ")" => raw::ExprKind::Tuple(t),
    <e1: Expr> <bok: BinOpKind> <e2: Expr> => raw::ExprKind::BinOp(bok, Box::new(e1), Box::new(e2)),
    <f: Expr> "(" <args: Sep<Expr, ",">> ")" => raw::ExprKind::App(Box::new(f), args),
    <e: Expr> <i: r"[0-9]+"> => raw::ExprKind::TupleField(Box::new(e), i),
    "if" <bexp: Expr> <c1: Block> "else" <c2: Block> => raw::ExprKind::If(Box::new(bexp), c1, c2),
    <b: Block> => raw::ExprKind::Block(b)
}

Expr : raw::Expr = {
    <lo:@L> <k:ExprKind> <hi:@R> => raw::Expr {
        kind: k,
        span: Span(lo, hi)
    }
}


// Handles internal only. External has already been taken care of.
FuncBody : raw::FuncBody = {
    "{" <e: Expr> "}" => raw::FuncBody::Internal(e)
}

// <T, V>
Generics : raw::Generics = {
    <lo:@L> "<" <p: Sep<Ident, ",">> ">" <hi:@R> => raw::Generics {
        params: p,
        span: Span(lo, hi)
    }
}

// extern type Foo = crate::fo::Foo;
TypeDef : raw::TypeDef = {
    "extern" "type" <n: Ident> <g: Generics?> "=" <p: IdentPath> ";" => raw::TypeDef {
        name: n,
        generics: g,
        path: p
    }
}

// Foo<A, B> => named
// fn(A, B) -> C => Func
// (Foo, Bar) => Tuple
TypeKind : raw::TypeKind = {
    <n: Ident> <p: Sep<Type, ",">?> => raw::TypeKind::Named(n, p),
    "fn" "(" <p: Sep<Type, ",">> ")" "->" <ret: Type> => raw::TypeKind::Func(p, Box::new(ret)),
    "(" <types: Sep<Type, ",">> ")" => raw::TypeKind::Tuple(types)
}


Type : raw::Type = {
    <lo:@L> <i:Ident> <hi:@R> => raw::Type {
        kind: k,
        span(lo, hi)
    }
}

// parses foo<T>(arg1: Type1, arg2: Type2) -> Type3
//Question: How to create a vector of tuples with regex syntax??
FuncSig : raw::FuncSig = {
    <n:Ident> <g:Generics?> "(" <a:Sep<(<Ident> ":" <Type>), ",">?> ")" "->" <r:Type> => 
    raw::FuncSig {
        name: n,
        generics: g,
        args: a,
        ret: r
    }
}

// extern fn foo<T>(x: EqGuard<T>, y: EqGuard<T>) -> EqGuard<T> {body}
FuncDef : raw::FuncDef = {
    "extern" "fn" <s: FuncSig> ";" => raw::FuncDef {
            sig: s,
            body: raw::FuncBody::External
        },

    "fn" <s: FuncSig> <b:FuncBody> => raw::FuncDef {
            sig: s,
            body: b
        }
}

ItemKind : raw::ItemKind = {
    <f:FuncDef> => raw::ItemKind::FuncDef(f),
    <t:TypeDef> => raw::ItemKind::Typedef(t)
}


Item : raw::Item = {
    <lo:@L> <k:ItemKind> <hi:@R> => raw::Item {
        kind: k,
        span: ast::Span(lo, hi)
    }
}

pub Program : raw::Program = {
    <i:Item*> => raw::Program {items: i}
}
